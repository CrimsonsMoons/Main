---// StarterPlayerScripts > LocalScript

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local workspace = game:GetService("Workspace")

local LocalPlayer = Players.LocalPlayer

-- >>> CHANGE THIS TO YOUR NPC FOLDER <<<
local FOLDER_PATH = workspace:WaitForChild("NPCs")

-- Combat remote (Toggle Attack)
local CombatRemote = ReplicatedStorage
	:WaitForChild("CombatSystem", 9e9)
	:WaitForChild("Remotes", 9e9)
	:WaitForChild("RequestHit", 9e9)

-- Quest remote
local QuestRemote = ReplicatedStorage
	:WaitForChild("RemoteEvents", 9e9)
	:WaitForChild("QuestAccept", 9e9)

-- Quest list
local quests = {
	{ DisplayName = "Theivs (Lv. 1–99)",				   Arg = "QuestNPC1"  },
	{ DisplayName = "Theiv Boss (Lv. 100–249)",		   Arg = "QuestNPC2"  },
	{ DisplayName = "Monkeys (Lv. 250–499)",			   Arg = "QuestNPC3"  },
	{ DisplayName = "Monkey Boss (Lv. 500–749)",		   Arg = "QuestNPC4"  },
	{ DisplayName = "Desert Bandits (Lv. 750–999)",	   Arg = "QuestNPC5"  },
	{ DisplayName = "Desert Bandit Boss (Lv. 1000–1499)", Arg = "QuestNPC6"  },
	{ DisplayName = "Frost Rouge (Lv. 1500–1999)",		   Arg = "QuestNPC7"  },
	{ DisplayName = "Winter Warden Boss (Lv. 2000–2999)", Arg = "QuestNPC8"  },
	{ DisplayName = "Sorcerer Students (Lv. 3000–3999)",  Arg = "QuestNPC9"  },
	{ DisplayName = "Panda Sorcerer Boss (Lv. 4000–5000)",Arg = "QuestNPC10" },
	{ DisplayName = "Hollows (Lv. 5000–6250)",			   Arg = "QuestNPC11" },
}

local SAFETY_REFRESH_INTERVAL = 1.0
local UI_REFRESH_INTERVAL = 0.6
local POS_SMOOTH = 18
local ROT_SMOOTH = 18

---------------------------------------------------------------------
-- Helpers
---------------------------------------------------------------------

local function baseName(name)
	local stripped = name:gsub("%d+$", ""):gsub("%s+$", "")
	if stripped == "" then
		return name
	end
	return stripped
end

local function isSelectable(inst)
	return inst:IsA("Model") or inst:IsA("BasePart")
end

local function getPivotCFrame(inst)
	if inst:IsA("BasePart") then
		return inst.CFrame
	elseif inst:IsA("Model") then
		local ok, cf = pcall(function()
			return inst:GetPivot()
		end)
		if ok and cf then
			return cf
		end
	end
	return nil
end

local function dist(a, b)
	local d = a - b
	return (d.X * d.X + d.Y * d.Y + d.Z * d.Z) ^ 0.5
end

local function expAlpha(strength, dt)
	return 1 - math.exp(-strength * dt)
end

local function safeUnitXZ(v)
	local flat = Vector3.new(v.X, 0, v.Z)
	local m = flat.Magnitude
	if m < 1e-6 then
		return Vector3.new(0, 0, -1)
	end
	return flat / m
end

local function getTargetHumanoid(inst)
	if inst:IsA("Model") then
		return inst:FindFirstChildOfClass("Humanoid")
	end
	local parent = inst.Parent
	while parent do
		if parent:IsA("Model") then
			local h = parent:FindFirstChildOfClass("Humanoid")
			if h then
				return h
			end
		end
		parent = parent.Parent
	end
	return nil
end

local function targetIsDead(inst)
	local h = getTargetHumanoid(inst)
	return (h ~= nil and h.Health <= 0)
end

---------------------------------------------------------------------
-- Character
---------------------------------------------------------------------

local character
local hrp
local humanoid

local function bindCharacter(c)
	character = c
	hrp = c:WaitForChild("HumanoidRootPart", 10)
	humanoid = c:WaitForChild("Humanoid", 10)
end

LocalPlayer.CharacterAdded:Connect(bindCharacter)
if LocalPlayer.Character then
	bindCharacter(LocalPlayer.Character)
end

---------------------------------------------------------------------
-- Groups
---------------------------------------------------------------------

local groups = {}        -- [groupName] = {instances}
local groupOrder = {}    -- sorted group names
local selectedGroups = {}-- [groupName] = bool
local currentTarget = nil

local function rebuildGroups()
	local newGroups = {}

	for _, child in ipairs(FOLDER_PATH:GetChildren()) do
		if child and child.Parent and isSelectable(child) then
			local cf = getPivotCFrame(child)
			if cf then
				local b = baseName(child.Name)
				if not newGroups[b] then
					newGroups[b] = {}
				end
				table.insert(newGroups[b], child)
			end
		end
	end

	local nameSet = {}
	for name in pairs(newGroups) do
		nameSet[name] = true
	end
	for name, on in pairs(selectedGroups) do
		if on then
			nameSet[name] = true
		end
	end

	local order = {}
	for name in pairs(nameSet) do
		table.insert(order, name)
	end
	table.sort(order, function(a, b)
		return a:lower() < b:lower()
	end)

	groups = newGroups
	groupOrder = order
end

FOLDER_PATH.ChildAdded:Connect(rebuildGroups)
FOLDER_PATH.ChildRemoved:Connect(rebuildGroups)

task.spawn(function()
	while true do
		rebuildGroups()
		task.wait(SAFETY_REFRESH_INTERVAL)
	end
end)

local function pickClosestAcrossSelections()
	if not (hrp and hrp.Parent) then
		return nil
	end
	if next(selectedGroups) == nil then
		return nil
	end

	local myPos = hrp.Position
	local best = nil
	local bestD = math.huge

	for gName, on in pairs(selectedGroups) do
		if on then
			local list = groups[gName]
			if list then
				for i = #list, 1, -1 do
					local inst = list[i]
					if inst and inst.Parent and not targetIsDead(inst) then
						local cf = getPivotCFrame(inst)
						if cf then
							local d = dist(myPos, cf.Position)
							if d < bestD then
								bestD = d
								best = inst
							end
						end
					end
				end
			end
		end
	end

	return best
end

---------------------------------------------------------------------
-- Movement + positions
---------------------------------------------------------------------

local enabled = false
local positionMode = "Above"  -- "Above", "Below", "Behind"
local distanceAmount = 6      -- slider 1–12
local REACQUIRE_EVERY = 0.35
local reacquireCd = 0

local function computeTargetPosAndLook(targetInst)
	local tcf = getPivotCFrame(targetInst)
	if not tcf then
		return nil
	end

	local tPos = tcf.Position
	local newPos

	if positionMode == "Above" then
		newPos = tPos + Vector3.new(0, distanceAmount, 0)
	elseif positionMode == "Below" then
		newPos = tPos + Vector3.new(0, -distanceAmount, 0)
	else
		local backDir = -safeUnitXZ(tcf.LookVector)
		newPos = tPos + (backDir * distanceAmount)
	end

	local lookAt = tPos
	return newPos, lookAt
end

---------------------------------------------------------------------
-- Anti-fall / stabilizers
---------------------------------------------------------------------

local alignPos
local alignOri
local attHRP
local attGoal
local goalPart
local prevAutoRotate

local function ensureStabilizers()
	if not (hrp and humanoid) then
		return
	end
	if alignPos and alignOri and goalPart and attGoal and attHRP then
		return
	end

	goalPart = Instance.new("Part")
	goalPart.Name = "CFrameGoal"
	goalPart.Anchored = true
	goalPart.CanCollide = false
	goalPart.CanQuery = false
	goalPart.CanTouch = false
	goalPart.Transparency = 1
	goalPart.Size = Vector3.new(1, 1, 1)
	goalPart.Parent = workspace

	attGoal = Instance.new("Attachment")
	attGoal.Name = "GoalAttachment"
	attGoal.Parent = goalPart

	attHRP = hrp:FindFirstChild("StabilizeAttachment")
	if not attHRP then
		attHRP = Instance.new("Attachment")
		attHRP.Name = "StabilizeAttachment"
		attHRP.Parent = hrp
	end

	alignPos = Instance.new("AlignPosition")
	alignPos.Name = "StabilizeAlignPosition"
	alignPos.Attachment0 = attHRP
	alignPos.Attachment1 = attGoal
	alignPos.RigidityEnabled = false
	alignPos.ReactionForceEnabled = true
	alignPos.ApplyAtCenterOfMass = true
	alignPos.MaxForce = 1e9
	alignPos.MaxVelocity = math.huge
	alignPos.Responsiveness = 200
	alignPos.Parent = hrp

	alignOri = Instance.new("AlignOrientation")
	alignOri.Name = "StabilizeAlignOrientation"
	alignOri.Attachment0 = attHRP
	alignOri.Attachment1 = attGoal
	alignOri.RigidityEnabled = false
	alignOri.ReactionTorqueEnabled = true
	alignOri.MaxTorque = 1e9
	alignOri.Responsiveness = 200
	alignOri.Parent = hrp
end

local function removeStabilizers()
	if goalPart then
		goalPart:Destroy()
		goalPart = nil
	end
	if alignPos then
		alignPos:Destroy()
		alignPos = nil
	end
	if alignOri then
		alignOri:Destroy()
		alignOri = nil
	end
	if attGoal then
		attGoal:Destroy()
		attGoal = nil
	end
end

---------------------------------------------------------------------
-- Noclip
---------------------------------------------------------------------

local noclipConn
local savedCollide = {}

local function captureAndSetNoclip(on)
	if not character then
		return
	end
	for _, d in ipairs(character:GetDescendants()) do
		if d:IsA("BasePart") then
			if on then
				if savedCollide[d] == nil then
					savedCollide[d] = d.CanCollide
				end
				d.CanCollide = false
			else
				if savedCollide[d] ~= nil then
					d.CanCollide = savedCollide[d]
				end
			end
		end
	end
	if not on then
		savedCollide = {}
	end
end

local function startNoclip()
	if noclipConn then
		noclipConn:Disconnect()
	end
	noclipConn = RunService.Stepped:Connect(function()
		if enabled and character and humanoid and humanoid.Health > 0 then
			captureAndSetNoclip(true)
		end
	end)
end

local function stopNoclip()
	if noclipConn then
		noclipConn:Disconnect()
		noclipConn = nil
	end
	captureAndSetNoclip(false)
end

LocalPlayer.CharacterAdded:Connect(function()
	task.wait(0.1)
	if enabled then
		ensureStabilizers()
		startNoclip()
		captureAndSetNoclip(true)
		if humanoid then
			humanoid.AutoRotate = false
		end
	end
end)

---------------------------------------------------------------------
-- Movement loop
---------------------------------------------------------------------

local moveConn
local lastGoalCF

local function stopMove()
	if moveConn then
		moveConn:Disconnect()
		moveConn = nil
	end
	lastGoalCF = nil
end

local function startMove()
	stopMove()
	moveConn = RunService.RenderStepped:Connect(function(dt)
		if not enabled then
			return
		end
		if not (character and hrp and humanoid) then
			return
		end
		if humanoid.Health <= 0 then
			return
		end
		if next(selectedGroups) == nil then
			return
		end

		ensureStabilizers()
		if not goalPart then
			return
		end

		if currentTarget and (not currentTarget.Parent or targetIsDead(currentTarget)) then
			currentTarget = nil
			reacquireCd = 0
		end

		reacquireCd = reacquireCd - dt
		if reacquireCd <= 0 then
			reacquireCd = REACQUIRE_EVERY
			currentTarget = pickClosestAcrossSelections()
		end

		if not currentTarget or not currentTarget.Parent or targetIsDead(currentTarget) then
			return
		end

		local pos, lookAt = computeTargetPosAndLook(currentTarget)
		if not pos then
			return
		end

		local desiredCF = CFrame.new(pos, lookAt)

		if not lastGoalCF then
			lastGoalCF = desiredCF
		else
			local aP = expAlpha(POS_SMOOTH, dt)
			local aR = expAlpha(ROT_SMOOTH, dt)
			local alpha = math.min(aP, aR)
			lastGoalCF = lastGoalCF:Lerp(desiredCF, alpha)
		end

		goalPart.CFrame = lastGoalCF
		hrp.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
		hrp.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
	end)
end

---------------------------------------------------------------------
-- UI root + tabs
---------------------------------------------------------------------

local gui = Instance.new("ScreenGui")
gui.Name = "CFrameScannerUI"
gui.ResetOnSpawn = false
gui.Parent = LocalPlayer:WaitForChild("PlayerGui")

local mainFrame = Instance.new("Frame")
mainFrame.Size = UDim2.new(0, 480, 0, 360)
mainFrame.Position = UDim2.new(0, 30, 0, 140)
mainFrame.BackgroundColor3 = Color3.fromRGB(22, 22, 28)
mainFrame.BorderSizePixel = 0
mainFrame.Parent = gui
Instance.new("UICorner", mainFrame).CornerRadius = UDim.new(0, 14)

local mainStroke = Instance.new("UIStroke")
mainStroke.Thickness = 1
mainStroke.Transparency = 0.35
mainStroke.Color = Color3.fromRGB(140, 140, 170)
mainStroke.Parent = mainFrame

local topBar = Instance.new("Frame")
topBar.Size = UDim2.new(1, 0, 0, 44)
topBar.BackgroundColor3 = Color3.fromRGB(28, 28, 36)
topBar.BorderSizePixel = 0
topBar.Parent = mainFrame
Instance.new("UICorner", topBar).CornerRadius = UDim.new(0, 14)

local title = Instance.new("TextLabel")
title.BackgroundTransparency = 1
title.Size = UDim2.new(1, -16, 1, 0)
title.Position = UDim2.new(0, 12, 0, 0)
title.Font = Enum.Font.GothamBold
title.TextSize = 16
title.TextXAlignment = Enum.TextXAlignment.Left
title.TextColor3 = Color3.fromRGB(235, 235, 245)
title.Text = "Main"
title.Parent = topBar

-- Drag
do
	local dragging = false
	local dragStart
	local startPos

	topBar.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			dragging = true
			dragStart = input.Position
			startPos = mainFrame.Position
		end
	end)

	topBar.InputEnded:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			dragging = false
		end
	end)

	UserInputService.InputChanged:Connect(function(input)
		if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
			local delta = input.Position - dragStart
			mainFrame.Position = UDim2.new(
				startPos.X.Scale,
				startPos.X.Offset + delta.X,
				startPos.Y.Scale,
				startPos.Y.Offset + delta.Y
			)
		end
	end)
end

local function makeTabButton(text, pos)
	local b = Instance.new("TextButton")
	b.Size = UDim2.new(0, 90, 0, 26)
	b.Position = pos
	b.BackgroundColor3 = Color3.fromRGB(40, 40, 52)
	b.BorderSizePixel = 0
	b.Text = text
	b.TextColor3 = Color3.fromRGB(220, 220, 240)
	b.Font = Enum.Font.GothamSemibold
	b.TextSize = 13
	b.Parent = topBar
	Instance.new("UICorner", b).CornerRadius = UDim.new(0, 8)

	local stroke = Instance.new("UIStroke")
	stroke.Thickness = 1
	stroke.Color = Color3.fromRGB(160, 190, 255)
	stroke.Transparency = 0.7
	stroke.Parent = b

	return b, stroke
end

local tabMainBtn, tabMainStroke = makeTabButton("Main",    UDim2.new(1, -200, 0.5, -13))
local tabFarmBtn, tabFarmStroke = makeTabButton("Farming", UDim2.new(1, -100, 0.5, -13))

---------------------------------------------------------------------
-- Main tab widgets
---------------------------------------------------------------------

local function makeBtn(text, pos, size)
	local b = Instance.new("TextButton")
	b.Size = size
	b.Position = pos
	b.BackgroundColor3 = Color3.fromRGB(40, 40, 52)
	b.BorderSizePixel = 0
	b.Text = text
	b.TextColor3 = Color3.fromRGB(235, 235, 245)
	b.Font = Enum.Font.GothamSemibold
	b.TextSize = 14
	b.Parent = mainFrame
	Instance.new("UICorner", b).CornerRadius = UDim.new(0, 10)
	return b
end

local enableBtn = makeBtn("Enabled: OFF", UDim2.new(0, 12, 0, 56), UDim2.new(0, 160, 0, 34))
local modeBtn   = makeBtn("Mode: Above",  UDim2.new(0, 184, 0, 56), UDim2.new(0, 150, 0, 34))
local clearBtn  = makeBtn("Clear",        UDim2.new(0, 344, 0, 56), UDim2.new(0, 124, 0, 34))

local selectedLabel = Instance.new("TextLabel")
selectedLabel.BackgroundTransparency = 1
selectedLabel.Position = UDim2.new(0, 12, 0, 96)
selectedLabel.Size = UDim2.new(1, -24, 0, 20)
selectedLabel.Font = Enum.Font.Gotham
selectedLabel.TextSize = 13
selectedLabel.TextXAlignment = Enum.TextXAlignment.Left
selectedLabel.TextColor3 = Color3.fromRGB(200, 200, 215)
selectedLabel.Text = "Selected: (none)"
selectedLabel.Parent = mainFrame

local sliderLabel = Instance.new("TextLabel")
sliderLabel.BackgroundTransparency = 1
sliderLabel.Position = UDim2.new(0, 12, 0, 122)
sliderLabel.Size = UDim2.new(1, -24, 0, 20)
sliderLabel.Font = Enum.Font.Gotham
sliderLabel.TextSize = 13
sliderLabel.TextXAlignment = Enum.TextXAlignment.Left
sliderLabel.TextColor3 = Color3.fromRGB(200, 200, 215)
sliderLabel.Text = "Distance: 6"
sliderLabel.Parent = mainFrame

local sliderBG = Instance.new("Frame")
sliderBG.Position = UDim2.new(0, 12, 0, 150)
sliderBG.Size = UDim2.new(1, -24, 0, 10)
sliderBG.BackgroundColor3 = Color3.fromRGB(40, 40, 52)
sliderBG.BorderSizePixel = 0
sliderBG.Parent = mainFrame
Instance.new("UICorner", sliderBG).CornerRadius = UDim.new(1, 0)

local sliderFill = Instance.new("Frame")
sliderFill.Size = UDim2.new(0, 0, 1, 0)
sliderFill.BackgroundColor3 = Color3.fromRGB(120, 170, 255)
sliderFill.BorderSizePixel = 0
sliderFill.Parent = sliderBG
Instance.new("UICorner", sliderFill).CornerRadius = UDim.new(1, 0)

local ticks = Instance.new("Frame")
ticks.BackgroundTransparency = 1
ticks.Position = UDim2.new(0, 0, 1, 6)
ticks.Size = UDim2.new(1, 0, 0, 10)
ticks.Parent = sliderBG

local MIN_DIST, MAX_DIST = 1, 12
for i = MIN_DIST, MAX_DIST do
	local a = (i - MIN_DIST) / (MAX_DIST - MIN_DIST)
	local t = Instance.new("Frame")
	t.AnchorPoint = Vector2.new(0.5, 0)
	t.Position = UDim2.new(a, 0, 0, 0)
	t.Size = UDim2.new(0, 1, 0, (i == MIN_DIST or i == MAX_DIST or i == 6) and 10 or 6)
	t.BackgroundColor3 = Color3.fromRGB(140, 140, 170)
	t.BackgroundTransparency = (i == MIN_DIST or i == MAX_DIST or i == 6) and 0.25 or 0.5
	t.BorderSizePixel = 0
	t.Parent = ticks
end

local minLabel = Instance.new("TextLabel")
minLabel.BackgroundTransparency = 1
minLabel.Position = UDim2.new(0, 0, 1, 18)
minLabel.Size = UDim2.new(0, 40, 0, 16)
minLabel.Font = Enum.Font.Gotham
minLabel.TextSize = 12
minLabel.TextColor3 = Color3.fromRGB(170, 170, 190)
minLabel.TextXAlignment = Enum.TextXAlignment.Left
minLabel.Text = tostring(MIN_DIST)
minLabel.Parent = sliderBG

local maxLabel = Instance.new("TextLabel")
maxLabel.BackgroundTransparency = 1
maxLabel.Position = UDim2.new(1, -40, 1, 18)
maxLabel.Size = UDim2.new(0, 40, 0, 16)
maxLabel.Font = Enum.Font.Gotham
maxLabel.TextSize = 12
maxLabel.TextColor3 = Color3.fromRGB(170, 170, 190)
maxLabel.TextXAlignment = Enum.TextXAlignment.Right
maxLabel.Text = tostring(MAX_DIST)
maxLabel.Parent = sliderBG

local sliderKnob = Instance.new("Frame")
sliderKnob.Size = UDim2.new(0, 18, 0, 18)
sliderKnob.Position = UDim2.new(0, -9, 0.5, -9)
sliderKnob.BackgroundColor3 = Color3.fromRGB(235, 235, 245)
sliderKnob.BorderSizePixel = 0
sliderKnob.Parent = sliderBG
Instance.new("UICorner", sliderKnob).CornerRadius = UDim.new(1, 0)

local knobBubble = Instance.new("TextLabel")
knobBubble.BackgroundColor3 = Color3.fromRGB(28, 28, 36)
knobBubble.BorderSizePixel = 0
knobBubble.Size = UDim2.new(0, 26, 0, 18)
knobBubble.Position = UDim2.new(0.5, -13, 0, -24)
knobBubble.Font = Enum.Font.GothamSemibold
knobBubble.TextSize = 12
knobBubble.TextColor3 = Color3.fromRGB(235, 235, 245)
knobBubble.Text = tostring(distanceAmount)
knobBubble.Parent = sliderKnob
Instance.new("UICorner", knobBubble).CornerRadius = UDim.new(0, 8)

local draggingSlider = false

local function setDistanceFromAlpha(a)
	a = math.clamp(a, 0, 1)
	local val = math.floor(MIN_DIST + (MAX_DIST - MIN_DIST) * a + 0.5)
	distanceAmount = val
	sliderLabel.Text = "Distance: " .. tostring(distanceAmount)
	knobBubble.Text = tostring(distanceAmount)

	local px = a * sliderBG.AbsoluteSize.X
	sliderFill:TweenSize(UDim2.new(0, px, 1, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.08, true)
	TweenService:Create(sliderKnob, TweenInfo.new(0.08, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		Position = UDim2.new(0, px - 9, 0.5, -9)
	}):Play()
end

local function updateSliderFromMouse(x)
	local left = sliderBG.AbsolutePosition.X
	local w = sliderBG.AbsoluteSize.X
	setDistanceFromAlpha((x - left) / w)
end

sliderBG.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		draggingSlider = true
		updateSliderFromMouse(input.Position.X)
	end
end)

sliderBG.InputEnded:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		draggingSlider = false
	end
end)

UserInputService.InputChanged:Connect(function(input)
	if draggingSlider and input.UserInputType == Enum.UserInputType.MouseMovement then
		updateSliderFromMouse(input.Position.X)
	end
end)

local listFrame = Instance.new("ScrollingFrame")
listFrame.Position = UDim2.new(0, 12, 0, 188)
listFrame.Size = UDim2.new(1, -24, 1, -200)
listFrame.BackgroundColor3 = Color3.fromRGB(28, 28, 36)
listFrame.BorderSizePixel = 0
listFrame.ScrollBarThickness = 8
listFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
listFrame.Parent = mainFrame
Instance.new("UICorner", listFrame).CornerRadius = UDim.new(0, 12)

local layout = Instance.new("UIListLayout")
layout.Padding = UDim.new(0, 6)
layout.Parent = listFrame

local function updateSelectedLabel()
	local names = {}
	for gName, on in pairs(selectedGroups) do
		if on then
			table.insert(names, gName)
		end
	end
	table.sort(names, function(a, b)
		return a:lower() < b:lower()
	end)

	if #names == 0 then
		selectedLabel.Text = "Selected: (none)"
	else
		local shown = {}
		for i = 1, math.min(4, #names) do
			table.insert(shown, names[i])
		end
		local extra = #names - #shown
		local txt = "Selected: " .. table.concat(shown, ", ")
		if extra > 0 then
			txt = txt .. " +" .. tostring(extra)
		end
		selectedLabel.Text = txt
	end
end

local function clearList()
	for _, c in ipairs(listFrame:GetChildren()) do
		if c:IsA("Frame") or c:IsA("TextButton") then
			c:Destroy()
		end
	end
end

local function tweenSelect(btn, stroke, selected)
	local goalBg = selected and Color3.fromRGB(72, 95, 150) or Color3.fromRGB(40, 40, 52)
	local goalTr = selected and 0.0 or 0.6
	TweenService:Create(btn, TweenInfo.new(0.14, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		BackgroundColor3 = goalBg
	}):Play()
	TweenService:Create(stroke, TweenInfo.new(0.14, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		Transparency = goalTr
	}):Play()
end

local function rebuildListUI()
	clearList()
	local y = 0

	for _, gName in ipairs(groupOrder) do
		local row = Instance.new("Frame")
		row.Size = UDim2.new(1, -10, 0, 32)
		row.BackgroundTransparency = 1
		row.Parent = listFrame

		local btn = Instance.new("TextButton")
		btn.Size = UDim2.new(1, 0, 1, 0)
		btn.BackgroundColor3 = Color3.fromRGB(40, 40, 52)
		btn.BorderSizePixel = 0
		btn.TextColor3 = Color3.fromRGB(235, 235, 245)
		btn.Font = Enum.Font.GothamSemibold
		btn.TextSize = 14
		btn.TextXAlignment = Enum.TextXAlignment.Left
		btn.Parent = row
		Instance.new("UICorner", btn).CornerRadius = UDim.new(0, 10)

		local glow = Instance.new("UIStroke")
		glow.Thickness = 2
		glow.Color = Color3.fromRGB(160, 190, 255)
		glow.Transparency = 0.6
		glow.Parent = btn

		local count = (groups[gName] and #groups[gName]) or 0
		btn.Text = ("  %s  (%d)"):format(gName, count)

		local selected = selectedGroups[gName] == true
		if selected then
			btn.BackgroundColor3 = Color3.fromRGB(72, 95, 150)
			glow.Transparency = 0.0
		end

		btn.MouseButton1Click:Connect(function()
			selectedGroups[gName] = not selectedGroups[gName]
			currentTarget = nil
			tweenSelect(btn, glow, selectedGroups[gName] == true)
			updateSelectedLabel()
		end)

		y = y + 38
	end

	listFrame.CanvasSize = UDim2.new(0, 0, 0, math.max(y, listFrame.AbsoluteSize.Y))
end

-- Main tab buttons

enableBtn.MouseButton1Click:Connect(function()
	enabled = not enabled
	enableBtn.Text = enabled and "Enabled: ON" or "Enabled: OFF"

	if humanoid and prevAutoRotate == nil then
		prevAutoRotate = humanoid.AutoRotate
	end

	if enabled then
		if humanoid then
			humanoid.AutoRotate = false
		end
		ensureStabilizers()
		startMove()
		startNoclip()
		captureAndSetNoclip(true)
		if goalPart and hrp then
			goalPart.CFrame = hrp.CFrame
		end
	else
		stopMove()
		stopNoclip()
		removeStabilizers()
		if humanoid and prevAutoRotate ~= nil then
			humanoid.AutoRotate = prevAutoRotate
		end
	end
end)

modeBtn.MouseButton1Click:Connect(function()
	if positionMode == "Above" then
		positionMode = "Below"
	elseif positionMode == "Below" then
		positionMode = "Behind"
	else
		positionMode = "Above"
	end
	modeBtn.Text = "Mode: " .. positionMode
end)

clearBtn.MouseButton1Click:Connect(function()
	selectedGroups = {}
	currentTarget = nil
	updateSelectedLabel()
	rebuildGroups()
	rebuildListUI()
end)

---------------------------------------------------------------------
-- Farming tab (Attack + Quests)
---------------------------------------------------------------------

local farmingFrame = Instance.new("Frame")
farmingFrame.Position = UDim2.new(0, 12, 0, 56)
farmingFrame.Size = UDim2.new(1, -24, 1, -68)
farmingFrame.BackgroundColor3 = Color3.fromRGB(28, 28, 36)
farmingFrame.BorderSizePixel = 0
farmingFrame.Visible = false
farmingFrame.Parent = mainFrame
Instance.new("UICorner", farmingFrame).CornerRadius = UDim.new(0, 12)

local farmTitle = Instance.new("TextLabel")
farmTitle.BackgroundTransparency = 1
farmTitle.Position = UDim2.new(0, 12, 0, 10)
farmTitle.Size = UDim2.new(1, -24, 0, 24)
farmTitle.Font = Enum.Font.GothamBold
farmTitle.TextSize = 16
farmTitle.TextXAlignment = Enum.TextXAlignment.Left
farmTitle.TextColor3 = Color3.fromRGB(230, 230, 245)
farmTitle.Text = "Farming"
farmTitle.Parent = farmingFrame

local farmDesc = Instance.new("TextLabel")
farmDesc.BackgroundTransparency = 1
farmDesc.Position = UDim2.new(0, 12, 0, 36)
farmDesc.Size = UDim2.new(1, -24, 0, 40)
farmDesc.Font = Enum.Font.Gotham
farmDesc.TextSize = 13
farmDesc.TextXAlignment = Enum.TextXAlignment.Left
farmDesc.TextYAlignment = Enum.TextYAlignment.Top
farmDesc.TextWrapped = true
farmDesc.TextColor3 = Color3.fromRGB(190, 190, 210)
farmDesc.Text = "Toggle Attack fires RequestHit every 0.01s. Turn OFF if you lag."
farmDesc.Parent = farmingFrame

-- Toggle Attack

local attackToggle = Instance.new("TextButton")
attackToggle.Size = UDim2.new(0, 200, 0, 36)
attackToggle.Position = UDim2.new(0, 12, 0, 86)
attackToggle.BackgroundColor3 = Color3.fromRGB(50, 60, 90)
attackToggle.BorderSizePixel = 0
attackToggle.Font = Enum.Font.GothamSemibold
attackToggle.TextSize = 14
attackToggle.TextColor3 = Color3.fromRGB(235, 235, 245)
attackToggle.Text = "Toggle Attack: OFF"
attackToggle.Parent = farmingFrame
Instance.new("UICorner", attackToggle).CornerRadius = UDim.new(0, 10)

local attackStroke = Instance.new("UIStroke")
attackStroke.Thickness = 2
attackStroke.Color = Color3.fromRGB(160, 190, 255)
attackStroke.Transparency = 0.6
attackStroke.Parent = attackToggle

local attackEnabled = false

local function updateAttackButton()
	local on = attackEnabled
	attackToggle.Text = on and "Toggle Attack: ON" or "Toggle Attack: OFF"
	local goalColor = on and Color3.fromRGB(80, 140, 100) or Color3.fromRGB(50, 60, 90)
	local goalTr = on and 0.1 or 0.6
	TweenService:Create(attackToggle, TweenInfo.new(0.12, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		BackgroundColor3 = goalColor
	}):Play()
	TweenService:Create(attackStroke, TweenInfo.new(0.12, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		Transparency = goalTr
	}):Play()
end

attackToggle.MouseButton1Click:Connect(function()
	attackEnabled = not attackEnabled
	updateAttackButton()
end)

task.spawn(function()
	local args = {}
	while true do
		if attackEnabled then
			pcall(function()
				CombatRemote:FireServer(unpack(args))
			end)
			task.wait(0.01)
		else
			task.wait(0.05)
		end
	end
end)

-- Quests UI

local questTitle = Instance.new("TextLabel")
questTitle.BackgroundTransparency = 1
questTitle.Position = UDim2.new(0, 12, 0, 136)
questTitle.Size = UDim2.new(1, -24, 0, 22)
questTitle.Font = Enum.Font.GothamBold
questTitle.TextSize = 14
questTitle.TextXAlignment = Enum.TextXAlignment.Left
questTitle.TextColor3 = Color3.fromRGB(220, 220, 240)
questTitle.Text = "Quests"
questTitle.Parent = farmingFrame

local questSelectedLabel = Instance.new("TextLabel")
questSelectedLabel.BackgroundTransparency = 1
questSelectedLabel.Position = UDim2.new(0, 12, 0, 158)
questSelectedLabel.Size = UDim2.new(1, -24, 0, 18)
questSelectedLabel.Font = Enum.Font.Gotham
questSelectedLabel.TextSize = 13
questSelectedLabel.TextXAlignment = Enum.TextXAlignment.Left
questSelectedLabel.TextColor3 = Color3.fromRGB(190, 190, 210)
questSelectedLabel.Text = "Selected Quest: (none)"
questSelectedLabel.Parent = farmingFrame

local questList = Instance.new("ScrollingFrame")
questList.Position = UDim2.new(0, 12, 0, 182)
questList.Size = UDim2.new(0.6, -18, 1, -196)
questList.BackgroundColor3 = Color3.fromRGB(24, 24, 32)
questList.BorderSizePixel = 0
questList.ScrollBarThickness = 6
questList.CanvasSize = UDim2.new(0, 0, 0, 0)
questList.Parent = farmingFrame
Instance.new("UICorner", questList).CornerRadius = UDim.new(0, 10)

local questLayout = Instance.new("UIListLayout")
questLayout.Padding = UDim.new(0, 6)
questLayout.Parent = questList

local selectedQuestIndex = nil
local autoQuestEnabled = false

local function updateQuestSelectedLabel()
	if not selectedQuestIndex then
		questSelectedLabel.Text = "Selected Quest: (none)"
	else
		local q = quests[selectedQuestIndex]
		if q then
			questSelectedLabel.Text = "Selected Quest: " .. q.DisplayName
		else
			questSelectedLabel.Text = "Selected Quest: (none)"
		end
	end
end

local function rebuildQuestList()
	for _, c in ipairs(questList:GetChildren()) do
		if c:IsA("TextButton") or c:IsA("Frame") then
			c:Destroy()
		end
	end

	local y = 0
	for i, q in ipairs(quests) do
		local btn = Instance.new("TextButton")
		btn.Size = UDim2.new(1, -6, 0, 26)
		btn.BackgroundColor3 = Color3.fromRGB(40, 40, 52)
		btn.BorderSizePixel = 0
		btn.Font = Enum.Font.GothamSemibold
		btn.TextSize = 13
		btn.TextXAlignment = Enum.TextXAlignment.Left
		btn.TextColor3 = Color3.fromRGB(230, 230, 245)
		btn.Text = "  " .. q.DisplayName
		btn.Parent = questList
		Instance.new("UICorner", btn).CornerRadius = UDim.new(0, 8)

		local glow = Instance.new("UIStroke")
		glow.Thickness = 1.5
		glow.Color = Color3.fromRGB(160, 190, 255)
		glow.Transparency = 0.7
		glow.Parent = btn

		if selectedQuestIndex == i then
			btn.BackgroundColor3 = Color3.fromRGB(70, 90, 130)
			glow.Transparency = 0.2
		end

		btn.MouseButton1Click:Connect(function()
			-- click again to deselect
			if selectedQuestIndex == i then
				selectedQuestIndex = nil
			else
				selectedQuestIndex = i
			end
			updateQuestSelectedLabel()
			rebuildQuestList()
		end)

		y = y + 32
	end

	questList.CanvasSize = UDim2.new(0, 0, 0, math.max(y, questList.AbsoluteSize.Y))
end

local questAcceptBtn = Instance.new("TextButton")
questAcceptBtn.Size = UDim2.new(0.35, -10, 0, 32)
questAcceptBtn.Position = UDim2.new(0.63, 0, 0, 182)
questAcceptBtn.BackgroundColor3 = Color3.fromRGB(60, 80, 110)
questAcceptBtn.BorderSizePixel = 0
questAcceptBtn.Font = Enum.Font.GothamSemibold
questAcceptBtn.TextSize = 13
questAcceptBtn.TextColor3 = Color3.fromRGB(235, 235, 245)
questAcceptBtn.Text = "Accept Quest"
questAcceptBtn.Parent = farmingFrame
Instance.new("UICorner", questAcceptBtn).CornerRadius = UDim.new(0, 10)

local questAcceptStroke = Instance.new("UIStroke")
questAcceptStroke.Thickness = 1.5
questAcceptStroke.Color = Color3.fromRGB(160, 190, 255)
questAcceptStroke.Transparency = 0.4
questAcceptStroke.Parent = questAcceptBtn

questAcceptBtn.MouseButton1Click:Connect(function()
	if not selectedQuestIndex then
		return
	end
	local q = quests[selectedQuestIndex]
	if not q then
		return
	end

	local args = {
		[1] = q.Arg,
	}
	pcall(function()
		QuestRemote:FireServer(unpack(args))
	end)
end)

-- Auto Quest toggle

local autoQuestToggle = Instance.new("TextButton")
autoQuestToggle.Size = UDim2.new(0.35, -10, 0, 32)
autoQuestToggle.Position = UDim2.new(0.63, 0, 0, 222)
autoQuestToggle.BackgroundColor3 = Color3.fromRGB(50, 60, 90)
autoQuestToggle.BorderSizePixel = 0
autoQuestToggle.Font = Enum.Font.GothamSemibold
autoQuestToggle.TextSize = 13
autoQuestToggle.TextColor3 = Color3.fromRGB(235, 235, 245)
autoQuestToggle.Text = "Auto Quest: OFF"
autoQuestToggle.Parent = farmingFrame
Instance.new("UICorner", autoQuestToggle).CornerRadius = UDim.new(0, 10)

local autoQuestStroke = Instance.new("UIStroke")
autoQuestStroke.Thickness = 1.5
autoQuestStroke.Color = Color3.fromRGB(160, 190, 255)
autoQuestStroke.Transparency = 0.6
autoQuestStroke.Parent = autoQuestToggle

local function updateAutoQuestButton()
	local on = autoQuestEnabled
	autoQuestToggle.Text = on and "Auto Quest: ON" or "Auto Quest: OFF"
	local goalColor = on and Color3.fromRGB(80, 140, 100) or Color3.fromRGB(50, 60, 90)
	local goalTr = on and 0.1 or 0.6
	TweenService:Create(autoQuestToggle, TweenInfo.new(0.12, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		BackgroundColor3 = goalColor
	}):Play()
	TweenService:Create(autoQuestStroke, TweenInfo.new(0.12, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		Transparency = goalTr
	}):Play()
end

autoQuestToggle.MouseButton1Click:Connect(function()
	autoQuestEnabled = not autoQuestEnabled
	updateAutoQuestButton()
end)

-- Auto-run selected quest every 0.5s only if toggle is ON

task.spawn(function()
	while true do
		if autoQuestEnabled and selectedQuestIndex then
			local q = quests[selectedQuestIndex]
			if q then
				local args = {
					[1] = q.Arg,
				}
				pcall(function()
					QuestRemote:FireServer(unpack(args))
				end)
			end
			task.wait(0.5)
		else
			task.wait(0.1)
		end
	end
end)

---------------------------------------------------------------------
-- Tabs logic
---------------------------------------------------------------------

local currentTab = "Main"
local mainWidgets = {
	enableBtn,
	modeBtn,
	clearBtn,
	selectedLabel,
	sliderLabel,
	sliderBG,
	listFrame,
}

local function setTab(tab)
	currentTab = tab
	local isMain = (tab == "Main")

	for _, inst in ipairs(mainWidgets) do
		inst.Visible = isMain
	end
	farmingFrame.Visible = not isMain

	title.Text = tab

	TweenService:Create(tabMainBtn, TweenInfo.new(0.12), {
		BackgroundColor3 = isMain and Color3.fromRGB(70, 80, 120) or Color3.fromRGB(40, 40, 52)
	}):Play()
	TweenService:Create(tabMainStroke, TweenInfo.new(0.12), {
		Transparency = isMain and 0.3 or 0.7
	}):Play()

	local farmSelected = not isMain
	TweenService:Create(tabFarmBtn, TweenInfo.new(0.12), {
		BackgroundColor3 = farmSelected and Color3.fromRGB(70, 80, 120) or Color3.fromRGB(40, 40, 52)
	}):Play()
	TweenService:Create(tabFarmStroke, TweenInfo.new(0.12), {
		Transparency = farmSelected and 0.3 or 0.7
	}):Play()
end

tabMainBtn.MouseButton1Click:Connect(function()
	setTab("Main")
end)

tabFarmBtn.MouseButton1Click:Connect(function()
	setTab("Farming")
end)

---------------------------------------------------------------------
-- Init
---------------------------------------------------------------------

task.defer(function()
	rebuildGroups()
	updateSelectedLabel()
	rebuildListUI()
	setDistanceFromAlpha((distanceAmount - MIN_DIST) / (MAX_DIST - MIN_DIST))

	rebuildQuestList()
	updateQuestSelectedLabel()
	updateAutoQuestButton()

	setTab("Main")
end)

task.spawn(function()
	while gui.Parent do
		rebuildGroups()
		rebuildListUI()
		updateSelectedLabel()
		task.wait(UI_REFRESH_INTERVAL)
	end
end)
